use ::core::*;

// -------------------------------------------------------------
trait Iter s a {
    next: s a -> Option (a, s a);
};

// -------------------------------------------------------------
type Empty a = Empty;

/// impl Iter Empty a
impl Iter Empty a {
    next = \Empty. None;
};

/// ∀ a. Empty a
let empty = Empty;

// -------------------------------------------------------------
/// impl Iter Option a
impl Iter Option a {
    next = \o. match (o) {
        Some a => Some (a, None),
        None => None,
    };
};

/// ∀ a. a -> Option a
let single = Some;

// -------------------------------------------------------------
/// impl Iter List a
impl Iter List a {
    next = \xs. match (xs) {
        Nil       => None,
        Cons y ys => Some (y, ys),
    };
};

// -------------------------------------------------------------
type Seq a = Seq (a -> a) a;

/// impl Iter Seq a
impl Iter Seq a {
    next = \Seq f x. Some(x, Seq f (f x));
};

/// seq : ∀ a. (a -> a) -> a -> Seq a
let seq = Seq;

/// repeat : ∀ a. a -> Seq a
let repeat = Seq id;

/// zeros : Seq Int
let zeros = repeat 0;

/// ones : Seq Int
let ones = repeat 1;

/// counter : Int -> Seq Int
let counter = Seq #(1 +);

// -------------------------------------------------------------
type Map s a b = Map (a -> b) (s a);

/// impl Iter (Map a b) c requires Iter a b.
impl Iter (Map s a) b {
    next = \Map f it. {
        let @{next} = @{Iter s a};
        match (next it) {
            None => None,
            Some (x, it') => Some (f x, Map f it'),
        }
    };
};

/// map : ∀ a b c. (b -> c) -> a b -> Map a b c
let map = Map;

// -------------------------------------------------------------
type Filter s a = Filter (a -> Bool) (s a);

/// impl Iter (Filter a) b requires Iter a b.
impl Iter (Filter s) a {
    next = \Filter p xs. {
        let @{next} = @{Iter s a};
        let (res, _) = for
            (next xs, true)
            (\(_, flag). flag)
            (\(opt, _). match (opt) {
                None => (None, false),
                Some (x, xs') =>
                    if (p x)
                        (opt, false)
                    else
                        (next xs', true),
                }
            )
        ;
        match (res) {
            None => None,
            Some (y, ys) => Some (y, Filter p ys),
        }
    };
};

/// filter : ∀ a b. (b -> Bool) -> a b -> Filter a b
let filter = Filter;

// -------------------------------------------------------------
type TakeWhile s a = TakeWhile (a -> Bool) (s a);

/// impl Iter (TakeWhile a) b requires Iter a b.
impl Iter (TakeWhile s) a {
    next = \TakeWhile p it. {
        let @{next} = @{Iter s a};
        match (next it) {
            None => None,
            Some (x, it') =>
                if (p x)
                    Some (x, TakeWhile p it')
                else
                    None
            ,
        }
    };
};

/// take_while : ∀ a b. (b -> Bool) -> a b -> TakeWhile a b
let take_while = TakeWhile;

// -------------------------------------------------------------
type Take s a = Take Int (s a);

/// impl Iter (Take a) b requires Iter a b.
impl Iter (Take s) a {
    next = \Take n it. {
        let @{next} = @{Iter s a};
        if (0 >= n)
            None
        else match (next it) {
            None => None,
            Some (x, it') => Some (x, Take (n - 1) it'),
        }
    };
};

/// take : ∀ a b. Int -> a b -> Take a b
let take = Take;

// -------------------------------------------------------------
type ZipWith s a t b c = ZipWith (a -> b -> c) (s a) (t b);

/// impl Iter (ZipWith a b c d) e requires Iter a b, Iter c d.
impl Iter (ZipWith s a t b) c {
    next = \ZipWith f xs ys. {
        let @{next: next_s} = @{Iter s a};
        let @{next: next_t} = @{Iter t b};
        match ((next_s xs, next_t ys)) {
            (Some (x, xs'), Some (y, ys')) => Some (f x y, ZipWith f xs' ys'),
            _ => None,
        }
    };
};

/// zip_with : ∀ a b c d e. (b -> d -> e) -> a b -> c d -> ZipWith a b c d e
let zip_with = ZipWith;

/// zip : ∀ a b c d. c a -> d b -> ZipWith c a d b (a, b)
let zip = zip_with (\x.\y. (x,y));

/// enumerate : ∀ a b. b a -> ZipWith Seq Int b a (Int, a)
let enumerate = zip (counter 0);

// -------------------------------------------------------------
/// fold : ∀ s a b. (a -> b -> a) -> a -> s b -> a requires Iter s b.
*let fold = \op.\init.\it. {
    let @{next} = @{Iter s b};
    let (res,_,_) = for
        (init,true,it)
        (\(_,flag,_). flag)
        (\(a,_,it). match (next it) {
            None          => (a,false,it),
            Some (x, it') => (op a x, true, it'),
        })
    ;
    res
};

// -------------------------------------------------------------
trait Sink ci a co {
    update: ci -> a -> ci;
    finish: ci -> co;
};

// -------------------------------------------------------------
type Fold a b = Fold (a -> b -> a) a;

/// impl Sink (Fold a b) b a
impl Sink (Fold a b) b a {
    update = \Fold f a.\x. Fold f (f a x);
    finish = \Fold _ a. a;
};

// -------------------------------------------------------------
/// impl Sink (List a) a (List a)
impl Sink (List a) a (List a) {
    update = flip Cons;
    finish = list::reverse;
};

// -------------------------------------------------------------
/// collect : ∀ ci s a co. ci -> s a -> co requires Iter s a, Sink ci a co.
*let collect = \sink.\it. {
    let @{next} = @{Iter s a};
    let @{update, finish} = @{Sink ci a co};
    let (acc,_,_) = for
        (sink,true,it)
        (\(_,flag,_). flag)
        (\(sink,_,it). match (next it) {
            None          => (sink,false,it),
            Some (x, it') => (update sink x, true, it'),
        })
    ;
    finish acc
};

// -------------------------------------------------------------
/// impl Sink Int a Int
impl Sink Int a Int {
    update = \a.\_. a + 1;
    finish = \a. a;
};

*let count = collect 0;
*let count_if = \p.\xs. xs |> filter p |> count;
*let count_while = \p.\xs. xs |> take_while p |> count;

type List a = Nil | Cons a (List a);

let rec append = \xs.\ys. match (xs) {
    Cons z zs => Cons z (append zs ys),
    _ => ys,
};

let rec join = \xss. match (xss) {
    Cons xs xss_ => append xs (join xss_),
    _ => Nil,
};

let rec fmap = \f.\xs. match (xs) {
    Cons y ys => Cons (f y) (fmap f ys),
    _ => Nil,
};

use fmap as map;

/// Cartesian product (not zip)
let rec afmap = \fs.\xs. match (fs) {
    Nil => Nil,
    Cons g gs => append (fmap g xs) (afmap gs xs),
};

use ::core::control::*;

impl Functor List {
    fmap = ::core::list::fmap;
};

impl Applicative List {
    pure = \x. Cons x Nil;
    afmap = ::core::list::afmap;
};

impl Monad List {
    (?>) = \xs.\f. join (::core::list::fmap f xs);
};

use ::core::ops::*;
use ::core::combinator::*;

// tail-recursive.
let foldl = \op.\init.\xs.
    (init, xs) |> fix (\f.\(a, xs). match (xs) {
        Nil       => a,
        Cons y ys => f (op a y, ys),
    }
);

let reverse = foldl (flip Cons) Nil;

// not tail-recursive.
let rec foldr = \op.\init.\xs. match (xs) {
    Nil       => init,
    Cons y ys => op y (foldr op init ys),
};

// tail-recursive.
let foldr_tr = \op.\init.\xs. reverse xs |> foldl op init;

let filter_unordered = \pred.\xs. {
    (xs, Nil) |> fix (\f.\(xs, res).
    match (xs) {
        Nil => res,
        Cons y ys =>
            if (pred y)
                f (ys, Cons y res)
            else
                f (ys, res)
        ,
    })
};

let filter = \pred.\xs. filter_unordered pred xs |> reverse;

let partition = \pred.\xs. {
    (xs, Nil, Nil) |> fix (\f.\(xs, ls, rs).
    match (xs) {
        Nil       => (ls, rs),
        Cons y ys =>
            if (pred y)
                f (ys, ls, (Cons y rs))
            else
                f (ys, (Cons y ls), rs)
        ,
    })
};

let qsort = \cmp. {
    let rec sort = \xs. match (xs) {
        Nil       => Nil,
        Cons y ys => {
            let (ls, rs) = partition (cmp y) ys;
            append (sort ls) (Cons y (sort rs))
        },
    };
    sort
};

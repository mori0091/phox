type Result e a = Err e | Ok a;

let ok? = \res. match (res) {
    Err _ => false,
    Ok  _ => true,
};

let err? = \res. match (res) {
    Err _ => true,
    Ok  _ => false,
};

// -------------------------------------------------------------
use ::core::cmp::*;

impl Eq (Result e a) {
    (==) = \x.\y. match ((x,y)) {
        (Err x, Err y) => @{Eq e}.(==) x y,
        (Ok  x, Ok  y) => @{Eq a}.(==) x y,
        _ => false,
    };
    (!=) = \x.\y. match ((x,y)) {
        (Err x, Err y) => @{Eq e}.(!=) x y,
        (Ok  x, Ok  y) => @{Eq a}.(!=) x y,
        _ => true,
    };
};

// -------------------------------------------------------------
impl Ord (Result e a) {
    (<=) = \x.\y. match ((x,y)) {
        (Err x, Err y) => @{Ord e}.(<=) x y,
        (Err _, Ok  _) => true,
        (Ok  x, Ok  y) => @{Ord a}.(<=) x y,
        _ => false,
    };
    (<) = \x.\y. match ((x,y)) {
        (Err x, Err y) => @{Ord e}.(<) x y,
        (Err _, Ok  _) => true,
        (Ok  x, Ok  y) => @{Ord a}.(<) x y,
        _ => false,
    };
    (>=) = \x.\y. match ((x,y)) {
        (Err x, Err y) => @{Ord e}.(>=) x y,
        (Ok  _, Err _) => true,
        (Ok  x, Ok  y) => @{Ord a}.(>=) x y,
        _ => false,
    };
    (>) = \x.\y. match ((x,y)) {
        (Err x, Err y) => @{Ord e}.(>) x y,
        (Ok  _, Err _) => true,
        (Ok  x, Ok  y) => @{Ord a}.(>) x y,
        _ => false,
    };
};

// -------------------------------------------------------------
use ::core::control::*;

impl Functor (Result e) {
    fmap = \f.\x. match (x) {
        Ok a => Ok (f a),
        Err err => Err err,
    };
};

impl Applicative (Result e) {
    pure = \x. Ok x;
    afmap = \f.\x. match ((f, x)) {
        (Ok g, Ok a) => Ok (g a),
        (Err err, _) => Err err,
        (_, Err err) => Err err,
    };
};

impl Monad (Result e) {
    (?>) = \x.\f. match (x) {
        Ok a => f a,
        Err err => Err err,
    };
};

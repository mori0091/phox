use ::core::Int;

use ::core::ops::*;
use ::core::{
    __i64_add__,
    __i64_sub__,
    __i64_mul__,
    __i64_div__,
    __i64_neg__,
};

impl Add Int { (+) = \x.\y. __i64_add__ (x, y); };
impl Sub Int { (-) = \x.\y. __i64_sub__ (x, y); };
impl Mul Int { (*) = \x.\y. __i64_mul__ (x, y); };
impl Div Int { (/) = \x.\y. __i64_div__ (x, y); };
impl Neg Int { negate = \x. __i64_neg__ x; };

use ::core::cmp::*;
use ::core::{
    __i64_eq__,
    __i64_ne__,
    __i64_le__,
    __i64_lt__,
    __i64_ge__,
    __i64_gt__,
};

impl Eq Int {
    (==) = \x.\y. __i64_eq__ (x, y);
    (!=) = \x.\y. __i64_ne__ (x, y);
};

impl Ord Int {
    (<=) = \x.\y. __i64_le__ (x, y);
    (<)  = \x.\y. __i64_lt__ (x, y);
    (>=) = \x.\y. __i64_ge__ (x, y);
    (>)  = \x.\y. __i64_gt__ (x, y);
};

use ::core::option::*;

let __eq_Option_i64__ = \x.\y. match ((x,y)) {
    (None, None) => true,
    (Some a, Some b) => @{Eq Int}.(==) a b,
    _ => false,
};

impl Eq (Option Int) {
    (==) = __eq_Option_i64__;
    (!=) = \x.\y. ! (x `__eq_Option_i64__` y);
};

let __le_Option_i64__ = \x.\y. match ((x,y)) {
    (None, _) => true,
    (Some a, Some b) => @{Ord Int}.(<=) a b,
    _ => false,
};

impl Ord (Option Int) {
    (<=) = __le_Option_i64__;
    (<)  = \x.\y. x `@{Eq (Option Int)}.(!=)` y && x `__le_Option_i64__` y;
    (>=) = \x.\y. y `__le_Option_i64__` x;
    (>)  = \x.\y. x `@{Eq (Option Int)}.(!=)` y && y `__le_Option_i64__` x;
};

type Option a = None | Some a;

let some? = \opt. match (opt) {
    None => false,
    _    => true,
};

let none? = \opt. match (opt) {
    None => true,
    _    => false,
};

// -------------------------------------------------------------
use ::core::cmp::*;

impl Eq (Option a) {
    (==) = \x.\y. match ((x,y)) {
        (Some x, Some y) => @{Eq a}.(==) x y,
        (None, None) => true,
        _ => false,
    };
    (!=) = \x.\y. match ((x,y)) {
        (Some x, Some y) => @{Eq a}.(!=) x y,
        (None, None) => false,
        _ => true,
    };
};

// -------------------------------------------------------------
impl Ord (Option a) {
    (<=) = \x.\y. match ((x,y)) {
        (Some x, Some y) => @{Ord a}.(<=) x y,
        (None, _) => true,
        _ => false,
    };
    (<) = \x.\y. match ((x,y)) {
        (Some x, Some y) => @{Ord a}.(<) x y,
        (None, Some _) => true,
        _ => false,
    };
    (>=) = \x.\y. match ((x,y)) {
        (Some x, Some y) => @{Ord a}.(>=) x y,
        (_, None) => true,
        _ => false,
    };
    (>) = \x.\y. match ((x,y)) {
        (Some x, Some y) => @{Ord a}.(>) x y,
        (Some _, None) => true,
        _ => false,
    };
};

// -------------------------------------------------------------
use ::core::control::*;

impl Functor Option {
    fmap = \f.\x. match (x) {
        Some a => Some (f a),
        _ => None,
    };
};

impl Applicative Option {
    pure = \x. Some x;
    afmap = \f.\x. match ((f, x)) {
        (Some g, Some a) => Some (g a),
        _ => None,
    };
};

impl Monad Option {
    (?>) = \x.\f. match (x) {
        Some a => f a,
        _ => None,
    };
};

/*
 * These are already defined in default. see `assets/prelude.phx`.
 *
 * ```phox
 * type Option a = None | Some a;
 * type Result e a = Err e | Ok a;
 *
 * trait Monad m {
 *     (?>): m a -> (a -> m b) -> m b;
 * };
 *
 * impl Monad Option {
 *     (?>) = \a.\f. match (a) {
 *         None => None,
 *         Some x => f x,
 *     };
 * };
 *
 * impl Monad (Result e) {
 *     (?>) = \a.\f. match (a) {
 *         Err err => Err err,
 *         Ok ok  => f ok,
 *     };
 * };
 * ```
 */

let res1 =
Some 1 ?> (\x.
Some 2 ?> (\y.
Some (x + y)
));

let res2 =
Ok 3 ?> (\x.
Ok 4 ?> (\y.
Ok (x + y)
));

// Typically, `Monad (Result e)` is already implemented and sufficient, so there
// is no need to implement `Monad (Result <CONCRETE_TYPE>)`.
//
// You may implement specialized version if you want, like this:
// (e.g. to remove constraints or give a different behavior for a concrete type)
// ```
// impl Monad (Result ()) {
//     (?>) = \a.\f. match (a) {
//         Err () => Err (),
//         Ok ok  => f ok,
//     };
// };
// ```
// However, in such cases, both `@{Monad (Result ())}` and `@{Monad (Result e)}`
// will cause ambiguous errors.
//
// Why?: Because for example `Ok a` matches to both of `Monad (Result e)` and
// `Monad (Result ())`, so it cannot be disambiguated.


// (disambiguation example) Explicitly choose the generic Result e instance
let m = @{Monad (Result e)};
let res3 =
Err 5 `m.(?>)` (\x.
Ok  6 `m.(?>)` (\y.
Ok (x + y)
));

let res4 =
Ok 7 ?> (\x.
Ok 8 ?> (\y.
Ok (x + y)
));

let res5 =
Err 9 ?> (\x.
Ok 10 ?> (\y.
Ok (x + y)
));

(res1, res2, res3, res4, res5)
// => (Some 3, Ok 7, Err 5, Ok 15, Err 9): âˆ€ a b. (Option Int, Result a Int, Result Int Int, Result b Int, Result Int Int)

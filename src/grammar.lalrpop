use std::str::FromStr;

use crate::syntax::ast::TopLevel;
use crate::syntax::ast::{RawTypeDecl, RawVariant, RawType};
use crate::syntax::ast::{Item, Stmt, Expr, Lit, Pat};

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
} else {
    _
}

pub Program: Vec<TopLevel> = {
    <mut decls:TopLevelDecl*> <expr:TopLevelExpr?> => {
        match expr {
            None => decls,
            Some(e) => {
                decls.push(TopLevel::Item(Item::Expr(e)));
                decls
            }
        }
    }
};

TopLevelExpr: Expr = {
    <items:ItemList> => Expr::Block(items),
};

TopLevelDecl: TopLevel = {
    <TypeDecl> => TopLevel::TypeDecl(<>),
};

TypeDecl: RawTypeDecl = {
    "type" <name:ConIdent> <params:TypeParams> "=" <variants:VariantList> ";"
        => RawTypeDecl::SumType {
            name: name.clone(),
            params: params,
            variants: variants,
        },
    "type" <name:ConIdent> <params:TypeParams> "=" <tuple:TypeTuple> ";"
        => RawTypeDecl::SumType {
            name: name.clone(),
            params: params,
            variants: vec![RawVariant::Tuple(name.clone(), vec![tuple])],
        },
    "type" <name:ConIdent> <params:TypeParams> "=" <record:TypeRecord> ";"
        => RawTypeDecl::SumType {
            name: name.clone(),
            params: params,
            variants: vec![RawVariant::Tuple(name.clone(), vec![record])],
        },
};

TypeParams: Vec<String> = {
    <vars:Ident*> => vars
};

VariantList: Vec<RawVariant> = {
    <mut vs:(<Variant> "|")*> <v:Variant> => {
        vs.push(v);
        vs
    }
};

Variant: RawVariant = {
    // VariantRecord,
    VariantSimple,
};

VariantSimple: RawVariant = {
    <name:ConIdent> <ts:TypeAtom*> => {
        if ts.is_empty() {
            RawVariant::Unit(name.to_string())
        }
        else {
            RawVariant::Tuple(name.to_string(), ts)
        }
    }
};

Type: RawType = {
    TypeFun,
};

TypeFun: RawType = {
    <l:TypeApp> "->" <r:TypeFun> => RawType::Fun(Box::new(l), Box::new(r)),
    TypeApp,
};

TypeApp: RawType = {
    <f:TypeApp> <x:TypeAtom> => RawType::App(Box::new(f), Box::new(x)),
    TypeAtom,
};

TypeAtom: RawType = {
    TypeVar,
    TypeCon,
    TypeParen,
    TypeTuple,
    TypeRecord,
};

TypeVar: RawType = {
    Ident => RawType::VarName(<>.to_string()),
};

TypeCon: RawType = {
    ConIdent => RawType::ConName(<>.to_string()),
};

TypeParen: RawType = {
    "(" <t:Type> ")" => t,
};

TypeTuple: RawType = {
    "(" <ts:SepByComma<Type>> ")" => RawType::Tuple(ts),
};

TypeRecord: RawType = {
    "@" "{" <fields:SepByComma0<TypeRecordField>> "}"
        => RawType::Record(fields)
};

TypeRecordField: (String, RawType) = {
    <name:Ident> ":" <value:Type> => (name, value)
};

// ----------------------------------------------
KeywordLamda: String = {
    "\\" => <>.to_string(),
    "λ" => <>.to_string(),
};

// ----------------------------------------------
ItemList: Vec<Item> = {
    <mut v:(<Item> ";")*> <tail:Expr> => {
        v.push(Item::Expr(tail));
        v
    },
    <mut v:(<Item> ";")+> => {
        v.push(Item::Expr(Expr::Lit(Lit::Unit)));
        v
    },
};

Item: Item = {
    Stmt => Item::Stmt(<>),
    Expr => Item::Expr(<>),
};

// ----------------------------------------------
Stmt: Stmt = {
    StmtLet,
    StmtLetRec,
};

StmtLet: Stmt = {
    "let" <p:Pat> "=" <e:Expr> => Stmt::Let(p, Box::new(e)),
};

StmtLetRec: Stmt = {
    "let" "rec" <p:Pat> "=" <e:Expr> => Stmt::LetRec(p, Box::new(e)),
};

// ----------------------------------------------
pub Expr: Expr = {
    Expr0,
};

Expr0: Expr = {
    Expr1,
};

Expr1: Expr = {
    ExprAbs,
    ExprIf,
    ExprMatch,
    ExprCmp,
};

ExprAbs: Expr = {
    KeywordLamda <id:Ident> "." <body:Expr1> => Expr::abs(id, body),
};

ExprIf: Expr = {
    "if" "(" <cond:Expr1> ")" <e1:Expr1> "else" <e2:Expr1> => Expr::if_(cond, e1, e2),
};

ExprMatch: Expr = {
    "match" "(" <scrut:Expr1> ")" "{" <arms:SepByComma0<MatchArm>> "}"
        => Expr::match_(scrut, arms)
};

MatchArm: (Pat, Expr) = {
    <p:Pat> "=>" <e:Expr> => (p, e)
};

// 比較演算子 (infix)
ExprCmp: Expr = {
    <l:ExprAdd> "==" <r:ExprAdd> => Expr::app(Expr::app(Expr::var("=="), l), r),
    <l:ExprAdd> "!=" <r:ExprAdd> => Expr::app(Expr::app(Expr::var("!="), l), r),
    <l:ExprAdd> "<"  <r:ExprAdd> => Expr::app(Expr::app(Expr::var("<") , l), r),
    <l:ExprAdd> "<=" <r:ExprAdd> => Expr::app(Expr::app(Expr::var("<="), l), r),
    <l:ExprAdd> ">"  <r:ExprAdd> => Expr::app(Expr::app(Expr::var(">") , l), r),
    <l:ExprAdd> ">=" <r:ExprAdd> => Expr::app(Expr::app(Expr::var(">="), l), r),
    ExprAdd,
};

// 加減算 (infixl)
ExprAdd: Expr = {
    <l:ExprAdd> "+" <r:ExprMul> => Expr::app(Expr::app(Expr::var("+"), l), r),
    <l:ExprAdd> "-" <r:ExprMul> => Expr::app(Expr::app(Expr::var("-"), l), r),
    ExprMul,
};

// 乗除算 (infixl)
ExprMul: Expr = {
    <l:ExprMul> "*" <r:ExprInfixApp> => Expr::app(Expr::app(Expr::var("*"), l), r),
    <l:ExprMul> "/" <r:ExprInfixApp> => Expr::app(Expr::app(Expr::var("/"), l), r),
    ExprInfixApp,
};

// 中置構文
ExprInfixApp: Expr = {
    <l:ExprInfixApp> "`" <f:Ident> "`" <r:ExprInfixOp> => {
        Expr::app(Expr::app(Expr::var(f), l), r)
    },
    ExprInfixOp,
};

ExprInfixOp: Expr = {
    <l:ExprInfixOp> <op:Symbol> <r:ExprUnary> => {
        Expr::app(Expr::app(Expr::var(op), l), r)
    },
    ExprUnary,
};

// 単項演算子 (prefix)
ExprUnary: Expr = {
    "-" <r:ExprUnary> => Expr::app(Expr::var("neg"), r),
    "!" <r:ExprUnary> => Expr::app(Expr::var("not"), r),
    ExprApp,
};

// 関数適用（左結合）
ExprApp: Expr = {
    <f:ExprApp> <x:Atom> => Expr::app(f, x),
    Atom,
};

// 原子的な式
Atom: Expr = {
    Lit => Expr::Lit(<>),
    Ident => Expr::var(<>),
    ConIdent => Expr::var(<>),
    ExprParen,
    ExprTuple,
    ExprRecord,
    ExprBlock,
    ExprFieldAccess,
    ExprTupleAccess,
};

ExprParen: Expr = {
    "(" <e:Expr> ")" => e,
};

ExprTuple: Expr = {
    "(" <es:SepByComma<Expr>> ")" => Expr::Tuple(es),
};

ExprRecord: Expr = {
    "@" "{" <fields:SepByComma0<ExprRecordField>> "}"
        => Expr::Record(fields)
};

ExprRecordField: (String, Expr) = {
    <name:Ident> ":" <value:Expr> => (name, value)
};

ExprFieldAccess: Expr = {
    <base:Atom> "." <field:Ident> => Expr::field_access(base, field),
};

ExprTupleAccess: Expr = {
    <base:Atom> "." <index:Int> => Expr::tuple_access(base, index as usize),
};

ExprBlock: Expr = {
    "{" "}" => {
        Expr::Block(vec![Item::Expr(Expr::Lit(Lit::Unit))])
    },
    "{" <items:ItemList> "}" => {
        Expr::Block(items)
    },
};

// === pattern ===
Pat: Pat = {
    Pat0,
};

Pat0: Pat = {
    PatCon,
    PatAtom,
};

PatCon: Pat = {
    <name:ConIdent> <args:PatAtom*> => Pat::con(name, args),
};

PatAtom: Pat = {
    "_" => Pat::Wildcard,
    Lit => Pat::Lit(<>),
    Ident => Pat::var(<>),
    PatParen,
    PatTuple,
    PatRecord,
};

PatParen: Pat = {
    "(" <p:Pat> ")" => p,
};

PatTuple: Pat = {
    "(" <ps:SepByComma<Pat>> ")" => Pat::Tuple(ps),
};

PatRecord: Pat = {
    "@" "{" <fields:SepByComma0<PatRecordField>> "}"
        => Pat::Record(fields)
};

PatRecordField: (String, Pat) = {
    <name:Ident> ":" <pat:Pat> => (name, pat),
    <name:Ident> => (name.clone(), Pat::Var(name)) // 省略形
};

// === literal ===
Lit: Lit = {
    LitUnit,
    LitInt,
    LitBool,
};

LitUnit: Lit = {
    "()" => Lit::Unit,
};

LitBool: Lit = {
    "true" => Lit::Bool(true),
    "false" => Lit::Bool(false),
};

LitInt: Lit = {
    <Int> => Lit::Int(<>),
};

Int: i64 = {
    r"[+-]?[0-9]+" => i64::from_str(<>).unwrap(),
};

// === identifier ===
Ident: String = {
    r"[a-z_][a-zA-Z0-9_]*" => <>.to_string(),
    "(" <Symbol> ")" => <>.to_string(),
};

Symbol: String = {
    r"[*+-/!$%&=^?<>]+" => <>.to_string(),
};

ConIdent: String = {
    r"[A-Z][a-zA-Z0-9_]*" => <>.to_string(),
};

// === comma-separated list ===
// A comma-separated list of T elements. (1 or more)
// Except when there is only one element, the trailing comma is optional.
SepByComma<T>: Vec<T> = {
    <mut v:(<T> ",")+> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// A comma-separated list of T elements. (0 or more)
// The trailing comma is optional.
SepByComma0<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

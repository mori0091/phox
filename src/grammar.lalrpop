use crate::module::*;
use crate::syntax::ast::*;
use crate::syntax::token::{Token, LexicalError};

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        // --- キーワード ---
        "mod"   => Token::Mod,
        "use"   => Token::Use,
        "as"    => Token::As,
        "type"  => Token::Type,
        "trait" => Token::Trait,
        "impl"  => Token::Impl,
        "*let"  => Token::Starlet,
        "let"   => Token::Let,
        "rec"   => Token::Rec,
        "if"    => Token::If,
        "else"  => Token::Else,
        "match" => Token::Match,
        "true"  => Token::True,
        "false" => Token::False,
        "()"    => Token::Unit,

        // --- 演算子・記号 ---
        "::" =>  Token::ColonColon,
        "|(" =>  Token::SectionStart,

        "*"  =>  Token::Star,
        "/"  =>  Token::Slash,
        "%"  =>  Token::Percent,

        "+"  =>  Token::Plus,
        "-"  =>  Token::Minus,

        "==" =>  Token::Eq,
        "!=" =>  Token::Neq,
        "<"  =>  Token::Lt,
        "<=" =>  Token::Le,
        ">"  =>  Token::Gt,
        ">=" =>  Token::Ge,

        "&&" =>  Token::And,
        "||" =>  Token::Or,

        ">>" => Token::ComposeR,
        "<<" => Token::ComposeL,
        "|>" => Token::PipeR,
        "<|" => Token::PipeL,

        // --- 記号 ---
        "="  =>  Token::Assign,
        "->" =>  Token::Arrow,
        "=>" =>  Token::FatArrow,
        "@"  =>  Token::At,
        "\\" =>  Token::Backslash,
        "λ"  =>  Token::Lambda,
        "_"  =>  Token::Underscore,
        "."  =>  Token::Dot,
        ";"  =>  Token::Semi,
        ","  =>  Token::Comma,
        ":"  =>  Token::Colon,
        "`"  =>  Token::Backtick,
        "("  =>  Token::LParen,
        ")"  =>  Token::RParen,
        "{"  =>  Token::LBrace,
        "}"  =>  Token::RBrace,
        "["  =>  Token::LBracket,
        "]"  =>  Token::RBracket,
        "|"  =>  Token::VerticalBar,
        "!"  =>  Token::ExclamationMark,
        "#"  =>  Token::NumberSign,

        // --- 識別子・リテラル ---
        "mod_ident"   => Token::ModIdent(<String>),
        "identifier" => Token::Ident(<String>),
        "Identifier" => Token::ConIdent(<String>),
        "int"        => Token::Int(<i64>),

        // --- その他の演算子記号列 ---
        "infixOp" => Token::InfixOp(<String>),
    }
}

// ----------------------------------------------
lambda: Token = {
    "\\",
    "λ",
};

// ----------------------------------------------
pub Program: Vec<Item> = {
    ItemList,
};

// ----------------------------------------------
// === items ===
pub ItemList: Vec<Item> = {
    <mut v:(<Item> ";")*> <tail:Expr> => {
        v.push(Item::expr(tail));
        v
    },
    <mut v:(<Item> ";")+> => {
        v.push(Item::expr(Expr::unit()));
        v
    },
};

pub Item: Item = {
    Decl => Item::decl(<>),
    Stmt => Item::stmt(<>),
    Expr => Item::expr(<>),
};

// ----------------------------------------------
// === declarations ===
Decl: Decl = {
    DeclType => Decl::Type(<>),
    DeclTrait => Decl::Trait(<>),
    DeclImpl => Decl::RawImpl(<>),
    DeclStarlet => Decl::RawStarlet(<>),
}

// ----------------------------------------------
// === ADT type declarations ===
DeclType: RawTypeDef = {
    "type" <name:ConIdent> <params:TypeParams> "=" <variants:VariantList>
        => RawTypeDef::SumType {
            name: name.clone(),
            params: params,
            variants: variants,
        },
    "type" <name:ConIdent> <params:TypeParams> "=" <tuple:TypeTuple>
        => RawTypeDef::SumType {
            name: name.clone(),
            params: params,
            variants: vec![RawVariant::Tuple(name.clone(), vec![tuple])],
        },
    "type" <name:ConIdent> <params:TypeParams> "=" <record:TypeRecord>
        => RawTypeDef::SumType {
            name: name.clone(),
            params: params,
            variants: vec![RawVariant::Tuple(name.clone(), vec![record])],
        },
};

TypeParams: Vec<String> = {
    <vars:Ident*> => vars
};

// ----------------------------------------------
// === data constructors ===
VariantList: Vec<RawVariant> = {
    <mut vs:(<Variant> "|")*> <v:Variant> => {
        vs.push(v);
        vs
    }
};

Variant: RawVariant = {
    <name:ConIdent> <ts:TypeAtom*> => {
        if ts.is_empty() {
            RawVariant::Unit(name)
        }
        else {
            RawVariant::Tuple(name, ts)
        }
    }
};

// ----------------------------------------------
// === types ===
Type: RawType = {
    TypeFun,
};

TypeFun: RawType = {
    <l:TypeApp> "->" <r:TypeFun> => RawType::Fun(Box::new(l), Box::new(r)),
    TypeApp,
};

TypeApp: RawType = {
    <f:TypeApp> <x:TypeAtom> => RawType::App(Box::new(f), Box::new(x)),
    TypeAtom,
};

TypeAtom: RawType = {
    TypeVar,
    TypeCon,
    TypeParen,
    TypeTuple,
    TypeRecord,
};

TypeVar: RawType = {
    Ident => RawType::VarName(<>),
};

TypeCon: RawType = {
    PathCon => RawType::ConName(Symbol::Unresolved(<>)),
    <"()"> => RawType::ConName(Symbol::unit()), // Hmm..
};

TypeParen: RawType = {
    "(" <t:Type> ")" => t,
};

TypeTuple: RawType = {
    "(" <ts:SepByComma<Type>> ")" => RawType::Tuple(ts),
};

TypeRecord: RawType = {
    "@" "{" <fields:SepByComma0<TypeRecordField>> "}"
        => RawType::Record(fields)
};

TypeRecordField: (String, RawType) = {
    <name:Ident> ":" <value:Type> => (name, value)
};

// ----------------------------------------------
// === trait declarations ===
DeclTrait: RawTrait = {
    "trait" <name:ConIdent> <params:TypeParams> "{" <members:DeclTraitMember+> "}"
        => RawTrait { name: name, params: params, members: members, },
};

DeclTraitMember: RawTraitMember = {
    <name:Ident> ":" <ty:Type> ";"
        => RawTraitMember { name: name, ty: Box::new(ty), },
};

// ----------------------------------------------
// === impl declarations ===
DeclImpl: RawImpl = {
    "impl" <name:PathCon> <params:TypeAtom+> "{" <members:DeclImplMember+> "}"
        => RawImpl { name: Symbol::Unresolved(name), params: params, members: members, },
};

DeclImplMember: RawImplMember = {
    <name:Ident> "=" <expr:Expr> ";"
        => RawImplMember { name: name, expr: Box::new(expr) },
};

// ----------------------------------------------
DeclStarlet: RawStarlet = {
    "*let" <name:Ident> "=" <expr:Expr>
        => RawStarlet { name: name, expr: Box::new(expr) },
};

// ----------------------------------------------
// === path-glob pattern for `use` statements. ===
PathGlob: PathGlob = {
    "::" <ps:PathGlobNode> => PathGlob::Absolute(ps),
    <ps:PathGlobNode>      => PathGlob::Relative(ps),
};

PathGlobNode: PathGlobNode = {
    <ps:"mod_ident"*> <leaf:PathGlobLeaf> => {
        PathGlobNode::List(ps, leaf)
    },
    <ps:"mod_ident"+> "{" <tree:SepByComma<PathGlobNode>> "}" => {
        PathGlobNode::Tree(ps, tree)
    },
};

PathGlobLeaf: PathGlobLeaf = {
    // baz as quax
    <p:Ident> <alias:("as" <Ident>)?> => {
        PathGlobLeaf::Elem(p, alias)
    },
    // Baz as Quax
    <p:ConIdent> <alias:("as" <ConIdent>)?> => {
        PathGlobLeaf::Elem(p, alias)
    },
    "()" <alias:("as" <ConIdent>)?> => {
        PathGlobLeaf::Elem("()".to_string(), alias)
    },
    "*" => {
        PathGlobLeaf::Wildcard
    },
};

// ----------------------------------------------
// === path ===
Path: Path = {
    "::" <ps:PathList> => Path::absolute(ps),
    <ps:PathList> => Path::relative(ps),
};

PathList: Vec<String> = {
    <mut ps:"mod_ident"*> <leaf:PathLeaf> => {
        ps.push(leaf);
        ps
    },
};

PathLeaf: String = {
    ConIdent,
    IdentOps,
    <"identifier">,
};

PathCon: Path = {
    <mut ps:"mod_ident"*> <leaf:ConIdent> => {
        ps.push(leaf);
        Path::relative(ps)
    },
    "::" <mut ps:"mod_ident"*> <leaf:ConIdent> => {
        ps.push(leaf);
        Path::absolute(ps)
    },
};

// ----------------------------------------------
// === statements ===
Stmt: Stmt = {
    StmtMod,
    StmtUse,
    StmtLet,
    StmtLetRec,
};

StmtMod: Stmt = {
    "mod" <m:"identifier"> <items:ModBlock> => Stmt::Mod(m, items),
};

ModBlock: Option<Vec<Item>> = {
    "{" "}" => None,
    <("{" <ItemList> "}")?>,
};

StmtUse: Stmt = {
    "use" <ps:PathGlob> => Stmt::Use(ps),
};

StmtLet: Stmt = {
    "let" <p:Pat> "=" <e:Expr> => Stmt::Let(p, Box::new(e)),
};

StmtLetRec: Stmt = {
    "let" "rec" <p:Pat> "=" <e:Expr> => Stmt::LetRec(p, Box::new(e)),
};

// ----------------------------------------------
// === expressions ===
pub Expr: Expr = {
    Expr0,
};

Expr0: Expr = {
    ExprAbs,
    ExprIf,
    ExprMatch,
    Expr1,
};

ExprAbs: Expr = {
    lambda <p:Pat> "." <body:Expr0> => Expr::abs(p, body),
};

ExprIf: Expr = {
    "if" "(" <cond:Expr0> ")" <e1:Expr0> "else" <e2:Expr0> => Expr::if_(cond, e1, e2),
};

ExprMatch: Expr = {
    "match" "(" <scrut:Expr0> ")" "{" <arms:SepByComma0<MatchArm>> "}"
        => Expr::match_(scrut, arms)
};

MatchArm: (Pat, Expr) = {
    <p:Pat> "=>" <e:Expr> => (p, e)
};

Expr1: Expr = {
    ExprBool,
    Expr2,
};

// 論理演算
ExprBool: Expr = {
    <l:Expr1> <op:LogicalOp> <r:Expr2> => Expr::app(Expr::app(Expr::unresolved_var(op), l), r),
};

Expr2: Expr = {
    ExprCmp,
    Expr3,
};

// 比較演算子 (infix)
ExprCmp: Expr = {
    <l:Expr3> <op:CmpOp> <r:Expr3> => Expr::app(Expr::app(Expr::unresolved_var(op), l), r),
};

Expr3: Expr = {
    ExprAdd,
    Expr4,
};

// 加減算 (infixl)
ExprAdd: Expr = {
    <l:Expr3> <op:AddSubOp> <r:Expr4> => Expr::app(Expr::app(Expr::unresolved_var(op), l), r),
};

Expr4: Expr = {
    ExprMul,
    Expr5,
};


// 乗除算 (infixl)
ExprMul: Expr = {
    <l:Expr4> <op:MulDivOp> <r:Expr5> => Expr::app(Expr::app(Expr::unresolved_var(op), l), r),
};

Expr5: Expr = {
    ExprInfixApp,
    Expr6,
};

// 中置構文
ExprInfixApp: Expr = {
    <l:Expr5> "`" <f:Atom> "`" <r:Expr6> => {
        Expr::app(Expr::app(f, l), r)
    },
};

Expr6: Expr = {
    ExprInfixOp,
    Expr7,
};

ExprInfixOp: Expr = {
    <l:Expr6> <op:"infixOp"> <r:Expr7> => {
        Expr::app(Expr::app(Expr::unresolved_var(op), l), r)
    },
};

Expr7: Expr = {
    ExprPipeL,
    Expr8,
};

ExprPipeL: Expr = {
    <f:Expr8> <op:PipeLOp> <x:Expr7> => Expr::app(Expr::app(Expr::unresolved_var(op), f), x),
};

Expr8: Expr = {
    ExprPipeR,
    Expr9,
};

ExprPipeR: Expr = {
    <x:Expr8> <op:PipeROp> <f:Expr9> => Expr::app(Expr::app(Expr::unresolved_var(op), x), f),
};

Expr9: Expr = {
    ExprCompose,
    Expr10,
};

ExprCompose: Expr = {
    <f:Expr9> <op:CompositionOp> <g:Expr10> => Expr::app(Expr::app(Expr::unresolved_var(op), f), g),
};

Expr10: Expr = {
    ExprUnary,
    Expr11,
};

// 単項演算子 (prefix)
ExprUnary: Expr = {
    "-" <r:Expr10> => Expr::app(Expr::unresolved_var("negate"), r),
    "!" <r:Expr10> => Expr::app(Expr::unresolved_var("not"), r),
};

Expr11: Expr = {
    ExprApp,
    Atom,
};

// 関数適用（左結合）
ExprApp: Expr = {
    <f:Expr11> <x:Atom> => Expr::app(f, x),
};

// 原子的な式
Atom: Expr = {
    <l:@L> <e:Atom0> <r:@R> => Expr { span: (l, r), body: e.body, ty: None },
};

Atom0: Expr = {
    ExprSectionL,
    ExprSectionR,
    ExprSectionL_deprecated,
    ExprSectionR_deprecated,
    ExprParen,
    ExprVar,
    Lit => Expr::lit(<>),
    ExprTuple,
    ExprRecord,
    ExprTraitRecord,
    ExprBlock,
    ExprFieldAccess,
    ExprTupleAccess,
};

ExprSectionL: Expr = {
    "|(" <l:Atom> "`" <op:Atom> "`" "_"? ")" => {
        Expr::abs(
            Pat::unresolved_var("__rhs__"),
            Expr::app(Expr::app(op, l), Expr::unresolved_var("__rhs__"))
        )
    },
    "|(" <l:Atom> <op:InfixOps> "_"? ")" => {
        Expr::abs(
            Pat::unresolved_var("__rhs__"),
            Expr::app(Expr::app(Expr::unresolved_var(op), l), Expr::unresolved_var("__rhs__"))
        )
    },
};

ExprSectionR: Expr = {
    "|(" "_"? "`" <op:Atom> "`" <r:Atom> ")" => {
        Expr::abs(
            Pat::unresolved_var("__lhs__"),
            Expr::app(Expr::app(op, Expr::unresolved_var("__lhs__")), r)
        )
    },
    "|(" "_"? <op:InfixOps> <r:Atom> ")" => {
        Expr::abs(
            Pat::unresolved_var("__lhs__"),
            Expr::app(Expr::app(Expr::unresolved_var(op), Expr::unresolved_var("__lhs__")), r)
        )
    },
};

ExprSectionL_deprecated: Expr = {
    "#" "(" <l:Atom> "`" <op:Atom> "`" "_"? ")" => {
        Expr::abs(
            Pat::unresolved_var("__rhs__"),
            Expr::app(Expr::app(op, l), Expr::unresolved_var("__rhs__"))
        )
    },
    "#" "(" <l:Atom> <op:InfixOps> "_"? ")" => {
        Expr::abs(
            Pat::unresolved_var("__rhs__"),
            Expr::app(Expr::app(Expr::unresolved_var(op), l), Expr::unresolved_var("__rhs__"))
        )
    },
};

ExprSectionR_deprecated: Expr = {
    "#" "(" "_"? "`" <op:Atom> "`" <r:Atom> ")" => {
        Expr::abs(
            Pat::unresolved_var("__lhs__"),
            Expr::app(Expr::app(op, Expr::unresolved_var("__lhs__")), r)
        )
    },
    "#" "(" "_"? <op:InfixOps> <r:Atom> ")" => {
        Expr::abs(
            Pat::unresolved_var("__lhs__"),
            Expr::app(Expr::app(Expr::unresolved_var(op), Expr::unresolved_var("__lhs__")), r)
        )
    },
};

ExprParen: Expr = {
    "(" <e:Expr> ")" => e,
};

ExprVar: Expr = {
    Path => Expr::unresolved_qvar(<>),
};

ExprTuple: Expr = {
    "(" <es:SepByComma<Expr>> ")" => Expr::tuple(es),
};

ExprRecord: Expr = {
    "@" "{" <fields:SepByComma0<ExprRecordField>> "}"
        => Expr::record(fields)
};

ExprTraitRecord: Expr = {
    "@" "{" <raw:TraitHead> "}" => {
        Expr::raw_trait_record(raw)
    },
};

TraitHead: RawTraitHead = {
    <name:PathCon> <params:TypeAtom+> => {
        RawTraitHead { name: Symbol::Unresolved(name), params }
    },
};

ExprRecordField: (String, Expr) = {
    <name:Ident> "=" <value:Expr> => (name, value)
};

ExprFieldAccess: Expr = {
    <base:Atom> "." <field:Ident> => Expr::field_access(base, field),
};

ExprTupleAccess: Expr = {
    <base:Atom> "." <index:Int> => Expr::tuple_access(base, index as usize),
};

ExprBlock: Expr = {
    "{" "}" => {
        Expr::block(vec![Item::expr(Expr::unit())])
    },
    "{" <items:ItemList> "}" => {
        Expr::block(items)
    },
};

// ----------------------------------------------
// === pattern ===
Pat: Pat = {
    Pat0,
};

Pat0: Pat = {
    PatCon,
    PatAtom,
};

PatCon: Pat = {
    <name:PathCon> <args:PatConArg*> => Pat::unresolved_qcon(name, args),
};

PatConArg: Pat = {
    PatAtom,
    <name:PathCon> => Pat::unresolved_qcon(name, vec![]),
};

PatAtom: Pat = {
    "_" => Pat::Wildcard,
    Lit => Pat::Lit(<>),
    PatVar,
    PatParen,
    PatTuple,
    PatRecord,
};

PatVar: Pat = {
    Ident => Pat::unresolved_var(<>),
};

PatParen: Pat = {
    "(" <p:Pat> ")" => p,
};

PatTuple: Pat = {
    "(" <ps:SepByComma<Pat>> ")" => Pat::Tuple(ps),
};

PatRecord: Pat = {
    "@" "{" <fields:SepByComma0<PatRecordField>> "}"
        => Pat::Record(fields)
};

PatRecordField: (String, Pat) = {
    <name:Ident> "=" <pat:Pat> => (name, pat),
    <name:Ident> => (name.clone(), Pat::unresolved_var(name)) // 省略形
};

// === literal ===
Lit: Lit = {
    LitUnit,
    LitInt,
    LitBool,
};

LitUnit: Lit = {
    "()" => Lit::Unit,
};

LitBool: Lit = {
    "true" => Lit::Bool(true),
    "false" => Lit::Bool(false),
};

LitInt: Lit = {
    <Int> => Lit::Int(<>),
};

Int: i64 = {
    <a:"int"> => a,
};

// === identifier ===
Ident: String = {
    IdentOps,
    <"identifier">,
};

PrefixOps: String = {
    "!" => "not".to_string(),
};

LogicalOp: String = {
    "&&" => "&&".to_string(),
    "||" => "||".to_string(),
};

CmpOp: String = {
    "==" => "==".to_string(),
    "!=" => "!=".to_string(),
    "<"  => "<".to_string(),
    "<=" => "<=".to_string(),
    ">"  => ">".to_string(),
    ">=" => ">=".to_string(),
};

AddSubOp: String = {
    "+"  => "+".to_string(),
    "-"  => "-".to_string(),
};

MulDivOp: String = {
    "*"  => "*".to_string(),
    "/"  => "/".to_string(),
    "%"  => "%".to_string(),
};

PipeLOp: String = {
    "<|" => "<|".to_string(),
};

PipeROp: String = {
    "|>" => "|>".to_string(),
};

CompositionOp: String = {
    ">>" => ">>".to_string(),
    "<<" => "<<".to_string(),
};

InfixOps: String = {
    LogicalOp,
    CmpOp,
    AddSubOp,
    MulDivOp,
    <"infixOp">,
    PipeLOp,
    PipeROp,
    CompositionOp,
};

IdentOps: String = {
    "(" <InfixOps> ")",
    "(" <PrefixOps> ")",
};

ConIdent: String = {
    <"Identifier">,
};

// === comma-separated list ===
// A comma-separated list of T elements. (1 or more)
// Except when there is only one element, the trailing comma is optional.
SepByComma<T>: Vec<T> = {
    <mut v:(<T> ",")+> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// A comma-separated list of T elements. (0 or more)
// The trailing comma is optional.
SepByComma0<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

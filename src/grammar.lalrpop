use std::str::FromStr;
// use crate::syntax::ast::{TopLevel, Expr, Lit, Pat, TypeDecl, Variant};
// use crate::typesys::Type;
use crate::syntax::ast::{TopLevel, Expr, Lit, Pat};

grammar;

pub Program: Vec<TopLevel> = {
    <Expr> => vec![TopLevel::Expr(<>)],
};

// pub Program: Vec<TopLevel> = {
//     <xs:TopLevel*> => xs,
// };

// TopLevel: TopLevel = {
//     <TopLevelExpr> => TopLevel::Expr(<>),
// };

// TopLevelExpr: Expr = {
//     ExprAbs,
//     ExprLet,
//     ExprLetRec,
//     ExprIf,
//     ExprMatch,
//     // ExprCmp, // <- NG ;
//     //// 二項演算子や関数適用はトップレベルに記述できない
// };

// ----------------------------------------------
KeywordLamda: String = {
    "\\" => <>.to_string(),
    "λ" => <>.to_string(),
};

KeywordStruct: String = {
    "@" => <>.to_string(),
    "struct" => <>.to_string(),
};

// ----------------------------------------------
// 最上位: 式
pub Expr: Expr = {
    Expr0,
};

Expr0: Expr = {
    Expr1,
    ExprSeq,
};

ExprSeq: Expr = {
    <es:ExprList> => {
        es.into_iter().reduce(|acc, e| Expr::let_(Pat::Wildcard, acc, e)).unwrap()
    }
};

ExprList: Vec<Expr> = {
    <mut v:(<Expr1> ";")+> <e:Expr1?> => match e {
        None => {
            v.push(Expr::Lit(Lit::Unit));
            v
        }
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Expr1: Expr = {
    ExprAbs,
    ExprLet,
    ExprLetRec,
    ExprIf,
    ExprMatch,
    ExprCmp,
};

// λ抽象や let/if は「一番外側でしか出てこない」ようにする
ExprAbs: Expr = {
    KeywordLamda <id:Ident> "." <body:Expr1> => Expr::abs(id, body),
};

ExprLet: Expr = {
    "let" <p:Pat> "=" <e1:Expr1> ";" <e2:Expr1> => Expr::let_(p, e1, e2),
};

ExprLetRec: Expr = {
    "let" "rec" <p:Pat> "=" <e1:Expr1> ";" <e2:Expr1> => Expr::let_rec(p, e1, e2),
};

ExprIf: Expr = {
    "if" "(" <cond:Expr1> ")" <e1:Expr1> "else" <e2:Expr1> => Expr::if_(cond, e1, e2),
};

ExprMatch: Expr = {
    "match" "(" <scrut:Expr1> ")" "{" <arms:SepByComma0<MatchArm>> "}"
        => Expr::match_(scrut, arms)
};

MatchArm: (Pat, Expr) = {
    <p:Pat> "=>" <e:Expr> => (p, e)
};

// 比較演算子
ExprCmp: Expr = {
    <l:ExprAdd> "==" <r:ExprAdd> => Expr::app(Expr::app(Expr::var("=="), l), r),
    <l:ExprAdd> "!=" <r:ExprAdd> => Expr::app(Expr::app(Expr::var("!="), l), r),
    <l:ExprAdd> "<"  <r:ExprAdd> => Expr::app(Expr::app(Expr::var("<") , l), r),
    <l:ExprAdd> "<=" <r:ExprAdd> => Expr::app(Expr::app(Expr::var("<="), l), r),
    <l:ExprAdd> ">"  <r:ExprAdd> => Expr::app(Expr::app(Expr::var(">") , l), r),
    <l:ExprAdd> ">=" <r:ExprAdd> => Expr::app(Expr::app(Expr::var(">="), l), r),
    ExprAdd,
};

// 加減算
ExprAdd: Expr = {
    <l:ExprAdd> "+" <r:ExprMul> => Expr::app(Expr::app(Expr::var("+"), l), r),
    <l:ExprAdd> "-" <r:ExprMul> => Expr::app(Expr::app(Expr::var("-"), l), r),
    ExprMul,
};

// 乗除算
ExprMul: Expr = {
    <l:ExprMul> "*" <r:ExprApp> => Expr::app(Expr::app(Expr::var("*"), l), r),
    <l:ExprMul> "/" <r:ExprApp> => Expr::app(Expr::app(Expr::var("/"), l), r),
    ExprApp,
};

// 関数適用（左結合）
ExprApp: Expr = {
    <f:ExprApp> <x:Atom> => Expr::app(f, x),
    Atom,
};

// 原子的な式
Atom: Expr = {
    Lit => Expr::Lit(<>),
    Ident => Expr::var(<>),
    ConIdent => Expr::var(<>),
    ExprParen,
    ExprTuple,
    ExprBlock,
    ExprStruct,
};

ExprParen: Expr = {
    "(" <e:Expr> ")" => e,
};

ExprTuple: Expr = {
    "(" <es:SepByComma<Expr>> ")" => Expr::Tuple(es),
};

ExprStruct: Expr = {
    <name:ConIdent> KeywordStruct "{" <fields:SepByComma0<StructField>> "}"
        => Expr::Struct(name, fields)
};

StructField: (String, Expr) = {
    <name:Ident> ":" <value:Expr> => (name, value)
};

ExprBlock: Expr = {
    "{" <e:Expr?> "}" => match e {
        None    => Expr::Lit(Lit::Unit),
        Some(e) => e,
    }
};

// === pattern ===
Pat: Pat = {
    Pat0,
};

Pat0: Pat = {
    PatCon,
    PatAtom,
};

PatCon: Pat = {
    <name:ConIdent> <args:PatAtom*> => Pat::con(name, args),
};

PatAtom: Pat = {
    "_" => Pat::Wildcard,
    Lit => Pat::Lit(<>),
    Ident => Pat::var(<>),
    PatParen,
    PatTuple,
    PatStruct,
};

PatParen: Pat = {
    "(" <p:Pat> ")" => p,
};

PatTuple: Pat = {
    "(" <ps:SepByComma<Pat>> ")" => Pat::Tuple(ps),
};

PatStruct: Pat = {
    <name:ConIdent> KeywordStruct "{" <fields:SepByComma0<StructPatField>> "}"
        => Pat::Struct(name, fields)
};

StructPatField: (String, Pat) = {
    <name:Ident> ":" <pat:Pat> => (name, pat),
    <name:Ident> => (name.clone(), Pat::Var(name)) // 省略形
};

// === literal ===
Lit: Lit = {
    LitUnit,
    LitInt,
    LitBool,
};

LitUnit: Lit = {
    "()" => Lit::Unit,
};

LitBool: Lit = {
    "true" => Lit::Bool(true),
    "false" => Lit::Bool(false),
};

LitInt: Lit = {
    r"[0-9]+" => Lit::Int(i64::from_str(<>).unwrap()),
};

// === identifier ===
Ident: String = {
    r"[a-z_][a-zA-Z0-9_]*" => <>.to_string(),
};

ConIdent: String = {
    r"[A-Z][a-zA-Z0-9_]*" => <>.to_string(),
};

// === comma-separated list ===
// A comma-separated list of T elements. (1 or more)
// Except when there is only one element, the trailing comma is optional.
SepByComma<T>: Vec<T> = {
    <mut v:(<T> ",")+> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// A comma-separated list of T elements. (0 or more)
// The trailing comma is optional.
SepByComma0<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


// pub TypeDecl: TypeDecl = {
//     "type" <name:ConIdent> <params:TypeParams> "=" <variants:VariantList>
//         => TypeDecl::SumType {
//             name: name.clone(),
//             params: params,
//             variants: variants,
//         }
// };

// TypeParams: Vec<String> = {
//     <vars:Ident*> => vars
// };

// VariantList: Vec<Variant> = {
//     <mut vs:(<Variant> "|")*> <v:Variant> => {
//         vs.push(v);
//         vs
//     }
// };

// Variant: Variant = {
//     VariantRecord,
//     VariantSimple,
// };

// VariantRecord: Variant = {
//     <name:ConIdent> KeywordStruct "{" <fields:SepByComma0<StructTypeField>> "}"
//         => Variant::Record(name, fields)
// };

// StructTypeField: (String, Type) = {
//     <name:Ident> ":" <ty:Type> => (name, ty),
// };

// VariantSimple: Variant = {
//     <name:ConIdent> <ts:Type*> => {
//         if ts.is_empty() {
//             Variant::Unit(name.to_string())
//         }
//         else {
//             Variant::Tuple(name.to_string(), ts)
//         }
//     }
// };

// Type: Type = {
//     // oops. cannot use `Type::Var(TypeVarId)` for type variable `a`.
//     // Ident => Type::var(<>),
//     Ident => Type::con(<>), //
//     // todo
// };
